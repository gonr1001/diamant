
\documentclass{llncs}
\bibliographystyle{alpha}
\usepackage[T1]{fontenc}
\usepackage{dfd,hhline}
\usepackage{verbatim}
\setlength{\parskip}{1.5ex plus0.5ex minus0ex}


\newcommand{\ang}{\textsf}
\newcommand{\key}{\textsf}
\newcommand{\ita}{\textit}
\newcommand{\bld}{\textbf}
\newcommand{\dos}{\textsc}
\newcommand{\pro}{\texttt}

\newcommand{\saphir}{SAPHIR}
\newcommand{\diamant}{DIAMANT}
\newcommand{\tictac}{Tic-Tac}
\newcommand{\xp}{eXtreme Programming}
\def\eXit{$\epsilon$\kern-.100em \lower.5ex\hbox{X}\kern-.125emit}

\title{\bf{L'architecture d'un système de production des horaires
de cours et d'examens}}
\author{Ruben Gonzalez Rubio \\Domingo Palao Muñoz}
\institute{Département de génie électrique et de génie informatique \\
Université de Sherbrooke,\\
\email{Ruben.Gonzalez-Rubio@USherbrooke.ca} \\
\email{Domingo.Palao@USherbrooke.ca}}
\date{}

%%%%%%%%%%%%%%%%%%
\pagestyle{plain} %% to be commented when sent
\newcommand{\ints}{\renewcommand{\baselinestretch}{1.0}\small\normalsize}
\newcommand{\intm}{\renewcommand{\baselinestretch}{1.5}\small\normalsize}
\newcommand{\intd}{\renewcommand{\baselinestretch}{2.0}\small\normalsize}
%%%%%%%%%%%%%%%%%%

\begin{document}

\maketitle

\intd

\begin{abstract} \label{intro}
\input{resume.tex}
\end{abstract}

{\bf Mots clés :}
Production d'horaires,
Construction d'horaires,
Architecture ouverte,
Architecture extensible,
Bases de données,
Web.

\section{Introduction}
La production d'horaires est une tâche périodique effectuée dans
beaucoup d'insti\-tutions d'enseignement.  Ces institutions
produisent un ou plusieurs horaires par année pour les cours et
les examens. L'automatisation de cette production peut réduire son
coût de manière importante. Dans certains cas, l'automatisation
commence par l'utilisation d'un logiciel de construction
d'horaires; dans d'autres, elle commence par l'automatisation des
traitements associés au fonctionnement de l'institution, comme par
exemple le suivi des étudiants. Il existe des logiciels pour
effectuer la construction d'horaires, on peut citer comme exemples
DIAMANT \cite{gonzalezrubio00} et SAPHIR \cite{ferland94}, mais,
il en existe d'autres.

En général, les logiciels pour la création d'horaires utilisent
comme  entrée un ou plusieurs fichiers. Leur sortie est effectuée
également sur un ou plusieurs fichiers. Travailler avec des
fichiers est une sources de problèmes. Il faut cons\-trui\-re les
fichiers d'entrée à chaque fois qu'un horaire est produit. Il
existe deux cas~: une production manuelle des fichiers ou une
production automatisée. Si les fichiers sont produits
manuellement, les erreurs de frappe ou d'inattention peuvent
produire des effets inattendus dans le logiciel. Les erreurs sont
difficiles à trouver, car il faut vérifier toutes les données
manuellement. Dans le cas où les fichiers sont produits de manière
automatique, il faut que le logiciel s'assure de vérifier la
validité et la cohérence de toutes les données. Le deuxième
pro\-blème se manifeste lorsqu'un changement est introduit dans le
système (soit dans l'application de construction, soit dans celui
de la production de fichiers) ou si l'application de construction
est utilisé sur plusieurs sites différents, utilisant de formats
des données différents.

Une autre source de problèmes, encore plus coûteuse que la
précédente, est celle de l'introduction d'un changement dans le
système, soit dans le logiciel de construction, ou dans le
logiciel de la production ou bien dans les deux. Les changements
viennent de la part de responsables de l'institution, par exemple
une nouvelle nomenclature pour les locaux; nouvelle approche
pédagogique, qui change la constitution de groupes, etc. Ce
problème de modifier un logiciel n'est pas propre à la production
d'horaires. Il s'agit d'un problème général dans le développement
des logiciels.


La solution pour le premier problème passe par l'automatisation de
la vérification et de la, validation de données à la saisie des
données, afin d'assurer que le logiciel de construction travaille
sur les bonnes données. Le deuxième problème, est plus délicat à
traiter, si l'ensemble de logiciels de production ont été conçus
pour être modifiables (extensibles) le coût de faire une
modification sera faible, mais si le système est monolithique et
fermé une modification sera très coûteuse. Une manière de diminuer
les effets de ce problème est le développement de logiciel ayant,
entre autres, la qualité d'extensibilité.


Dans cet article nous proposons l'architecture  d'un système de
production des horaires de cours et des examens ayant les qualités
suivantes~: ouverte et extensible. Une telle architecture doit
contribuer à faire face plus facilement aux deux problèmes
mentionnés, en réduisant le coût des modifications et en
effectuant la vérification et la validation des données dans des
étapes précises du processus et en évitant la redondance du code
et des données. Cette architecture met en \oe{}uvre une base de
données, un site Internet et un logiciel de construction
d'horaires. La vérification et la validation de données  se font à
l'entrée de données et en appliquant des contraintes d'intégrité
dans la base de données.  Le site Web est utilisé principalement
pour la saisie de données, ceci permet de vérifier aussi la
validité des données, grâce aux règles d'affaires avant que la
donnée soit entrée dans la base. Une autre fonction du site Web
est d'offrir les horaires de manière personnalisé, une fois que
l'horaire est construit. La base de données permet l'extraction
des données, selon différents formats. Ainsi, l'entrée de données
du logiciel de construction est facilitée. Bien entendu, avec
l'aide du logiciel de construction d'horaires, il est possible de
fabriquer un horaire avec un minimum de conflits.



Des nombreuses recherches ont été faites dans la construction
d'horaires~: algorithmes et formulations mathématiques et
plusieurs logiciels ont été proposés dans les conférences PATAT
\cite{patat97,patat00,patat02}. Par contre, peu d'efforts ont été
consacrés jusqu'à présent au développement global de la production
d'horaires. Nous pensons que le fait d'avoir une vue globale sur
le processus peut aider la recherche en construction d'horaires.
White \cite{white00} a mis en évidence que le Web doit être
utilisé comme un moyen de diffusion d'horaires. Nous allons un peu
plus loin en proposant  de l'utiliser également comme interface
d'entrée, de plus nous proposons l'architecture nécessaire à
supporter nos idées. De Causmaecker et al \cite{decausmaecker02}
ont introduit l'idée que la sémantique du Web peut être utilisée
par les chercheurs en construction d'horaires. Ils ont aussi
introduit l'idée d'utiliser XML comme langage de communication
dans la construction d'horaires par agents. Nous proposons aussi
l'utilisation de XML, afin de faciliter les échanges entre
certains modules de notre architecture. Dans Burke et al.
\cite{burke97} il est proposé d'avoir un standard pour le format
de données pour des instances d'horaires, leur but était de
comparer des algorithmes (programmes) dans des ``benchmarks''.
Dans un travail plus récent, Kingston \cite{kingston02} propose un
language STTL et un interpréteur, avec le même objectif. Özcan
\cite{ozcan03} suggère aussi un autre standard pour définir des
instances de problèmes de construction d'horaires, ayant comme
base le langage XML. Il nous semble qu'il serait souhaitable
d'avoir un standard, mais c'est un but très difficile à atteindre.
À la place, notre approche permet d'utiliser une base de données
comme un outil d'extraction et de formattage, de cette manière le
logiciel de construction d'horaires peut recevoir les données
nécessaires. Ainsi, il serait possible de générer des instances de
problèmes pour d'autres logiciels de construction d'horaires.


Le développement de notre architecture a été divisé en deux
étapes.Nous avons analysé le flot des données dans un système
générique de production d'horaires. Ensuite nous avons défini
l'architecture, les blocs de base et la responsabilité de chaque
bloc qui participe dans l'architecture. Les objectifs de définir
une architecture ouverte et extensible ont été respectés pendant
nos travaux. Ceci est présenté dans les sections \ref{sec:data} et
\ref{sec:archi}.

Une fois l'architecture définie, nous avons créé une instance afin
de l'implanter dans un système de production d'horaires à
l'Université de Sherbrooke. Nous avons fait un survol des
technologies existantes afin de faire les bons choix respectant
encore les objectifs d'ouverture et d'extensibilité. Ceci est
présenté dans les sections \ref{sec:tech} et \ref{sec:tictac}.

Nous finissons par un bilan et des conclusions à la section
\ref{sec:conc}.



\section{Le flot de l'information dans la production d'horaires}
\label{sec:data}

Tout d'abord, nous définissons le processus de production
d'horaires comme un processus qui démarre lorsqu'on commence  la
saisie de données pour la période de validité de l'horaire $P$.
Cette période $P$ est un semestre, un  trimestre, ou une
année\footnote{À l'Université de Sherbrooke on parle de trimestre,
mais en réalité il comporte seize semaines (presque quatre mois),
donc le système doit s'adapter à toute période $P$.}. Le processus
est fini lorsque toutes les personnes concernées reçoivent
l'horaire sur un support papier ou sur le Web (voir figure
\ref{fig:fOne}) et que la période de validité de l'horaire touche
à sa fin. Les données à saisir sont multiples, par exemple, les
cours qui vont avoir lieu dans la période $P$; le format du cours
(3h, ou 2h+1h); les enseignants possibles ou assignés à certains
cours; les locaux possibles ou assignées; la disponibilité des
enseignants et des locaux, etc.. Si\-gnalons qu'il existe des
institutions où les étudiants font un pré-choix et d'autres où les
horaires sont faits sans pré-choix. Le pré-choix des étudiants
fait partie des données à saisir, s'il n'y a pas de pré-choix, il
faut indiquer le nombre d'étudiants à admettre pour chaque cours.


\begin{figure}[htb] \begin{center}
\setlength{\unitlength}{0.1cm}
\begin{picture}(90,35)
\deffilebox{20}{10}{0.2}
\defprocessbox{20}{16}
\put(0, 15){\fichier[\pro{Données}]}

\put( 20,20){\vector(1,0){15}}

\put(35, 12){\process[Système de\\production \\ d'horaires]}

\put(55, 20){\vector(1,0){7}} \put(62, 20){\corner[y]{-10}{8}}
\put(62, 20){\corner[y]{10}{8}}

\put(70, 25){\fichier[\pro{Papier}]}

\put(70, 5){\fichier[\pro{Web}]}
\end{picture}
\end{center}
\caption{La production d'horaires}\label{fig:fOne}
\end{figure}

La figure \ref{fig:fOne} est une vue abstraite de la production
d'horaires, le système de production inclut un logiciel de
construction d'horaires.



\begin{description}
\item[Système de production d'horaires] Il est composé de
plusieurs logiciels, ou modules, qui fonctionnent de manière
autonome, mais coordonnée. Il nous apparaît clair que  le système
doit avoir deux composantes principales~: le système de
sauve\-garde de données et le logiciel de construction d'horaires.

\item[Données] représentent des données nécessaires à la
production d'horaires. Nous allons sauvegarder toutes les données
nécessaires dans un système de sauvegarde de données. Dans la
figure, il n'est pas indiqué que ces données peuvent être
manipulées par des modules du système de production d'horaires.
Par exemple, le module de saisie de pré-choix, va sauvegarder les
cours suivis par un étudiant. Le module de construction de données
va prendre son entrée dans la base et lorsque la construction sera
faite les nouvelles données obtenues seront remises dans
l'entrepôt des données.


\item[Papier ou Web] Il s'agit de la sortie du système une fois
que l'horaire est construit. Ces sorties peuvent être des
fichiers, qui seront imprimés sur papier ou des données qui seront
affichés sur une page Web, dans le deux cas les données sources se
trouvent dans  la base de données.

\end{description}




\subsection{La préparation des données}
La figure \ref{fig:fTwo} montre l'évolution des données pendant la
production de l'horaire. L'évolution présente les instances des
données à différents instants du processus.

La répartition de données sur une seule base de données ou sur
plusieurs bases (base de données repartie) est un problème
d'implémentation. De manière conceptuelle il s'agit d'une seule
base de données.

\begin{figure}[htb] \begin{center}
\setlength{\unitlength}{0.1cm}
%\fbox{%
\begin{picture}(90,40)
\deffilebox{20}{10}{0.2}
\defprocessbox{20}{16}
%\put(0,0){\fichier[Données]}
%\put( 10, 2){\corner{20}{4}}
\put(0, 15){\fichier[$bd_{1}$]} \put(0, 5){\makebox(20,10){Données
de base}} \put(20, 20){\vector(1,0){10}} \put(30,
15){\fichier[$bd_{2}$]} \put(30, 5){\makebox(20,10){Données
période $P$}} \put(50, 20){\vector(1,0){10}} \put(60,
15){\fichier[$bd_{3}$]} \put(60, 5){\makebox(20,10){Données
horaire}}
\end{picture}%}
\end{center}

\caption{L'évolution des données pendant la production d'un
horaire}\label{fig:fTwo}
\end{figure}


\begin{description}
\item[Données de base] Ces données sont les données définies à
long terme dans l'entrepôt.  L'information des activités
pédagogiques d'un programme, les programmes offerts, les
enseignants, les caractéristiques de salles de cours, les
étudiants sont des exemples de ce type d'information. Il s'agit en
général des informations qui sont partagées par d'autres
applications. Par exemple un étudiant est décrit par son nom,
prénom, matricule, programme suivi, etc. Une application qui
utilise les données étudiants est par exemple celle qui permet
d'imprimer les notes d'un étudiant sur son bulletin. Ici, nous
nous intéressons aux données associées à la production d'horaires,
qui peut être une vue (une partie) de la base de données complète
de l'institution.


\item[Données période $P$] Ces données sont nécessaires à la
construction d'un horaire pour la période concernée, elles
contiennent les cours qui seront offerts à cette période, la
disponibilité de enseignants pour cette période, etc. Ces données
sont un préalable à la construction d'un horaire et sont saisies
avant chaque construction. Cependant, ces données vont changer
(mises-à-jour) pendant la construction de l'horaire. Par exemple
lorsque on trouve un enseignant externe pour un cours donné, on
saisira ses informations nom et disponibilité dans la base.

\item[Données horaire] Ces donnés sont le résultat de  la
construction de l'horaire. Elles vont contenir toutes les
informations nécessaires pour imprimer ou afficher des horaires
généraux et personnalisés.

\end{description}

Il est à noter qu'il existe deux grandes activités  dans la
production~: la saisie (mise-à-jour) de données et  la
construction de l'horaire. En général ces deux activités sont
effectuées par un ensemble de personnes. Il est aussi nécessaire
de voir comment ces activités s'effectuent dans le temps.


\begin{figure}[htb] \begin{center}
\setlength{\unitlength}{0.1cm}
%\fbox{%
\begin{picture}(90,40)
\put(-6,7){ \shortstack{b)}} \put(0, 10){\vector(1,0){90}}

\put(5, 9){\line(0,1){2}} \put(4,7){\shortstack{$t_0$}}

\put(85, 9){\line(0,1){2}} \put(84,7){\shortstack{$t_f$}}

\put(5, 12){\vector(1,0){75}}

\put(45, 14){\vector(1,0){40}}

 \put(9,13){ \shortstack{Saisie}}

 \put(54,16){ \shortstack{Construction}}

\put(-6,22){ \shortstack{a)}}\put(0, 25){\vector(1,0){90}}

\put(5, 24){\line(0,1){2}}
 \put(4,22){ \shortstack{$t_0$}}
\put(5, 27){\vector(1,0){40}}

\put(45, 27){\vector(1,0){40}}

\put(85, 24){\line(0,1){2}} \put(84,22){\shortstack{$t_f$}}

\put(9,28){ \shortstack{Saisie}}

\put(54,28){ \shortstack{Construction}}

\end{picture}%}
\end{center}

\caption{Les activités de saisie et construction pour une période
$P$}\label{fig:fTime}
\end{figure}

La figure \ref{fig:fTime} nous montre deux cas de l'évolution de
ces activités. Dans le cas a. la saisie et la construction sont
deux activités réalisées en séquence. Ceci arrive dans des cas
très rares. Dans le cas b. la saisie (surtout mis-à-jour) se fait
au même temps que la construction. Ceci est le cas général,
beaucoup de données sont figées, comme l'offre de cours, cependant
si pendant la construction on trouve des situations où les
conflits obligent à faire des changements sur les données, format
d'un cours, passer de 3h consécutives à 2h consécutives plus 1h.
D'autres cas peuvent se présenter.

En fonction de chaque instance du système, il faut définir le
schéma de la base de données, et les rôles et privileges des
utilisateurs.

Une autre dimension de ces deux activités est l'interaction des
utilisateurs avec la bases de données. Nous considérons deux types
d'utilisateurs~: le commis et le responsable de la construction.
Le commis est celui qui va saisir les données de base, le
responsable et celui qui est responsable de la construction de
l'horaire et qui interagit avec  le programme de construction
d'horaires.

Le commis va saisir ou mettre-à-jour  une donnée dans la base si
la données est valide,  elle est accepté et entrée dans la base.
Par exemple si la donne attendue est un entier dans un intervalle,
et que la donnée entrée correspond à l'ensemble de valeurs
attendues; elle sera entrée dans la base. Sinon, le commis doit
rentrer une nouvelle valeur. Bien entendu, il faut avoir
différentes priorités d'accès.

La construction d'horaires est une activité de nature itérative.
En général, les algorithmes de construction d'horaires proposent
de respecter les contraintes fortes et d'essayer de respecter le
plus possible de contraintes faibles, donc, le responsable va
essayer de trouver plusieurs solutions pour en choisir une. Dans
certains cas, il est possible de faire partir le programme avec
les mêmes données pour trouver une nouvelle solution. Dans
d'autres cas il est  nécessaire de changer les données de départ
pour obtenir une nouvelle solution. S'il faut faire $n$ essais la
solution choisie par le responsable sera la solution $s$ où $1
\leq s \leq n$. Il est nécessaire de prévoir une manière de
travailler avec la base de données afin de sauvegarder les
changements effectuées pour chaque itération et faire un
``commit'' lorsque la solution est choisie et que l'horaire
devient définitif pour la période.




\section{L'architecture} \label{sec:archi}


Suite à l'étude du flot de données dans la production d'horaires,
nous sommes en mesure de proposer une architecture pour
implémenter le système.

\subsection{Une architecture pour la production d'horaires}

De manière abstraite, une architecture logicielle décrit les
éléments composants d'un système, elle montre aussi les
interactions entre ces éléments, les modèles qui guident sa
composition et les contraintes de ces modèles. \cite{shaw96}

De façon générale, quand nous avons un problème complexe, la
meilleure approche est de découper le problème en fragments qui
sont plus faciles à gérer avec des solutions simples. Après, si
nous mettons ensemble ces petites solutions, nous allons arriver à
la solution de notre problème complexe \cite{buschmann96}.

À l'heure actuelle il y a plusieurs architectures disponibles pour
développer des applications logicielles,  la plus adaptée pour ce
type de problème est celle en couches.

L'architecture montré dans la figure \ref{fig:fThree} propose la
division du système en trois couches, chacune avec une fonction
bien définie~:

\begin{description}
\item [L'interface~:] Est responsable de valider la saisie des
données de l'utilisateur, ainsi que l'entrée des données qui vient
d'autres systèmes.

\item [La couche de logique d'affaires~:] Est responsable du
comportement du système, c'est à dire, les règles d'affaires sont
codées ici.

\item [La couche de persistance des données~:] Gère le stockage
physique des données, soit dans des fichiers avec un certain
format, ou dans un système de bases de données traditionnelle ou
bien dans d'autres modèles de persistance qui sont capables de
gérer des bases de données complexes.
\end {description}

\begin{figure}
\setlength{\unitlength}{1cm}
\begin{picture}(3,4.5)
  \put(3,4){\framebox(4,1){interface}}
  \put(4.5,3.5){\vector(0,1){0.5}}
  \put(5.5,4){\vector(0,-1){0.5}}
  \put(3,2.5){\framebox(4,1){logique d'affaires}}
  \put(4.5,2){\vector(0,1){0.5}}
  \put(5.5,2.5){\vector(0,-1){0.5}}
  \put(3,1){\framebox(4,1){persistance de données}}
\end{picture}
\caption{L'architecture trois couches.}\label{fig:fThree}
\end{figure}

\subsection {L'architecture trois couches et le système de production d'horaires}


Pour chaque élément de l'architecture que nous avons présenté dans
la section antérieure, nous proposons un composant qui fait partie
de l'application de production d'horaires. Dans cette section nous
allons montrer l'intégration entre le flot des données propre à un
système de production d'horaires et l'architecture proposée.

La conception de haut niveau de notre système de production
d'horaires est simple (voir figure \ref{fig:fOne})~:

\begin{enumerate}
\item Nous avons des données qui entrent dans le système. Ces
données sont gérées par la couche d'interface. Il y a trois
sources possibles des données (voir figure \ref{fig:fTwo}):

\begin{enumerate}
\item La saisie directe des données d'une période. Cette activité
est faite par l'utilisateur commis. Normalement, ces données
changent à chaque création d'un horaire. Pour saisir les données,
l'utilisateur commis a une page Web qui est affichée par un
navigateur où il aura tous les champs à remplir. À cette étape, la
couche d'interface peut faire quelques validations minimales de la
cohérence de données, par exemple, vérifier que le type de données
est correct, vérifier que les champs qui sont obligatoires sont
remplis, etc. Dépendant de la taille de l'institution, il peut
avoir plusieurs utilisateurs commis qui travaillent au même temps
dans l'application, il faut en conséquence, prendre les mesures
nécessaires pour permettre le travail concurrent dans la couche de
persistance de données.

\item Les données générées par d'autres systèmes (données de
base). Depuis long temps il est prouvé que la meilleure manière
d'échanger de l'information entre deux systèmes est le transfert
de fichiers. C'est pour cette raison que notre système doit être
capable de recevoir et envoyer des fichiers dans un format
compatible entre plusieurs systèmes.

\item Les données horaire sont créées par l'application de
création d'horaires. Cette application est gérée par l'utilisateur
responsable de la création d'horaires. Étant donné que cette
activité est de nature itérative, il peut avoir un certain nombre
de versions de travail que l'utilisateur responsable de la
création d'horaires doit analyser pour trouver celle qui lui
convient le mieux. Une fois qu'il a trouvé cette version, il doit
appliquer l'opération "commit" pour rendre disponible
l'information au reste des utilisateurs. Ce sont les données qui
sortent de notre système, et ils sont envoyés vers d'autres
systèmes ou bien vers d'autres utilisateurs, par exemple, les
étudiants qui vont recevoir un papier avec leur horaire
personnalisé ou bien, il peut consulter cette information en
utilisant un site Web crée pour ces fins, ou bien, l'organisme
d'administration central de l'institution qui doit être informé de
l'affectation des horaires.

\end{enumerate}

Il faut tenir en considération que la couche d'interface
communique uniquement avec la couche de logique d'affaires. Une
application n'est pas capable d'ajouter, modifier ou effacer des
données directement dans la base de données, elle doit passer
irrémédiablement par la couche de logique d'affaires. Cette
caractéristique nous permet d'assurer la cohérence des données.

\item Les données sont traitées selon certaines règles et
contraintes, ces règles sont définies par chaque institution et
elles sont codées dans la couche logique d'affaires. C'est ici que
nous pourrons exprimer des contraints propres à chaque
institution, par exemple, la quantité maximale d'étudiants dans un
groupe, tous les cours de mathématique se déroulent le matin, etc.

\item Les données résultats de ces traitements doivent être
stockes dans quelque part pour pouvoir être utilisées après sa
génération. C'est la couche de persistance de données qui est
responsable de cette tâche. Dans un système de production
d'horaires, les données peuvent être stockées dans une base de
données (relationnel, objet ou autre technologie), dans un fichier
XML, dans un fichier texte ou bien dans autre moyen de stockage
pertinent.
\end{enumerate}

Ces éléments de composition et ses relations sont illustrés dans
la figure \ref{fig:fFour}.

\begin{figure}
\setlength{\unitlength}{0.5cm}
\begin{picture}(19,7)

  \put (0,6){\line(1,0){22}}
  \put (19,6.5){\makebox(0,0){\scriptsize Couche d'interface}}
  \put(0,6.5){\framebox(4,1){\tiny Saisie de données}}
  \put(2,6.65){\makebox(0,0){\tiny (Client web)}}
  \put(5,6.5){\framebox(4,1){\tiny Création d'horaires}}
  \put(7,6.65){\makebox(0,0){\tiny (Interface)}}
  \put(10,6.5){\framebox(4,1){\tiny Autres systèmes}}
  \put(12,6.65){\makebox(0,0){\tiny (Interface)}}
  \put (2,6.5){\vector(1,-1){2}} %SD -> SW
  \put (4,4.5){\vector(-1,1){2}} %SW -> SD
  \put (7,6.5){\vector(-1,-1){2}} %CH -> SW
  \put (5,4.5){\vector(1,1){2}} %SW -> CH
  \put (7,6.5){\vector(1,-1){2}} %CH -> RA
  \put (9,4.5){\vector(-1,1){2}} %RA -> CH
  \put (12,6.5){\vector(-1,-1){2}} %AS -> RA
  \put (10,4.5){\vector(1,1){2}} %RA -> AS


  \put (0,3){\line(1,0){22}}
  \put (19,3.5){\makebox(0,0){\scriptsize couche de logique d'affaires}}
  \put (2,3.5){\framebox(4,1){\tiny Serveur Web}}
  \put (8,3.5){\framebox(4,1){\tiny Règles d'affaires}}
  \put (6,4){\vector(1,0){2}} %RA -> SW
  \put (8,4){\vector(-1,0){2}} %SW -> RA
  \put (10,3.5){\vector(-1,-1){2}} %RA -> BD
  \put (8,1.5){\vector(1,1){2}} %BD -> RA


  \put (0,0){\line(1,0){22}}
  \put (19,0.5){\makebox(0,0){\scriptsize Couche de persistance des données}}
  \put (5,0.5){\framebox(6,1){\tiny Serveur Base Données}}




\end{picture}
\caption{L'implementation de l'architecture trois couches pour le
système de production d'horaires.}\label{fig:fFour}
\end{figure}


\section{Technologies possibles}\label{sec:tech}

Pour l'implémentation de l'architecture, il faut en premier lieu,
trouver quels sont les éléments technologiques nécessaires. Nous
trouvons qu'il faut avoir~:

\begin{enumerate}
\item Un langage pour faciliter l'affichage des données vers
l'utilisateur ainsi que pour créer des formulaires pour saisir des
données.

\item Un ensemble de règles qui définissent la manière d'établir
l'échange des données avec les autres systèmes.

\item Un langage pour coder la logique d'affaires.

\item Un outil pour gérer la persistance des données.
\end{enumerate}

Après notre analyse, nous avons constaté qu'il n'y a pas une seule
option, plutôt il y a plusieurs possibilités pour implémenter
cette architecture.

Dans le Tableau \ref{tb:tbOne}, nous montrons une liste
d'instances possibles, il faut remarquer qu'elle n'est pas
exhaustive.

\begin{table}
\begin{tabular}{|c||c|c|c|}\hline
Technologie & Instance 1 & Instance 2 & Instance 3\\ \hline\hline
Langage pour affichage & HTML et JSP& Applet Java & Visual Basic\\
\hline
Format pour échanger données & XML & Text & Text\\ \hline

Langage pour coder la logique d'affaire & Java & Java & Visual Basic\\
\hline

La persistance de données & Base de données & Base de données & Base de données \\
\hline
\end{tabular}
~ \\
 \caption{ Quelques instances possibles de
l'architecture}\label{tb:tbOne}
\end{table}

Pour la construction de chaque instance nous avons pris en
considération une certaine logique, nous avons mit ensemble les
éléments qui ont des caractéristiques communes ou bien qui
appartiennent à un même famille de logiciels et qui sont ouverts,
c'est un critère de construction qui a été choisi de manière
arbitraire.

Pour le volet base de données, nous n'avons pas mentionné le nom
spécifique d'un système de gestion de base de données, le choix
reste ouvert à l'implementation.

Notre architecture est ouverte, étant donné qu'elle accepte
plusieurs instances. L'architecture est aussi extensible, parce
que nous pourrions changer les modules d'une manière facile, par
exemple, nous pouvons commencer avec un élément de persistance de
données comme un fichier en format texte plain, et après, nous
pourrions effectuer quelques changements dans l'élément
d'interface pour pouvoir interagir avec des fichiers en format
XML. Après, si nous voulons faire évoluer cette partie de
persistance de données vers un système de bases de données, il
faudrait faire des changements dans la couche d'interface et
programmer l'élément de persistance des données. Tous ces
changements sans jamais toucher l'élément de la logique
d'affaires. Dans le Tableau \ref{tb:tbTwo}, nous montrons
l'évolution possible d'une instance de notre architecture.

\begin{table}
\begin{tabular}{|c||c|c|c|}\hline
Technologie & Version 1 & Version 2 & Version 3\\ \hline\hline
Langage pour affichage & HTML et JSP & HTML et JSP & HTML et JSP\\
\hline

Format pour échanger données & Text & XML & SQL, Base de données\\
\hline

Langage pour coder la logique d'affaire & Java & Java & Java\\
\hline

La persistance de données & Text & XML & SQL, Base de données \\
\hline

\end{tabular}
~ \\

\caption{ L'evolution d'une instance de
l'architecture}\label{tb:tbTwo}
\end{table}

Nous pouvons aussi imaginer un système qui commence avec un
interface basé en affichage en mode textuel, qui va évoluer à un
affichage basé en HTML et JSP en utilisant un serveur Web.

\section{Une instance de l'architecture} \label{sec:tictac}

Une fois que nous avons établi l'architecture et que nous savons
qu'elle est ouverte et extensible, il faut que l'instance que nous
allons implémenter soit aussi ouverte et extensible. Nous avons
montré trois options d'instances de l'architecture (voir Tableau
\ref{tb:tbOne}), pour notre implémentation, nous avons choisi
l'option 1 de ce tableau.

De le départ, il faut savoir que un élément est ouvert s'il est
construit avec des standards approuvés, ou bien, s'il est
construit avec une spécification privée mais rendue publique par
les développeurs.
\footnote{http:\//\//www.webopedia.com\//TERM\//O\//open\_architecture.html}

Il faut aussi tenir en compte que un élément est extensible s'il
est facile d'adapter ce produit aux changements dans la
spécification.\cite{meyer97}


Avec ces considerations en main, nous montrons ici l'analyse qui
nous a amené à notre choix:

\begin{description}

\item [Langage pour affichage:] Pour langage d'affichage et saisie
de données nous avons choisi HTML et JSP, étant donnée que ces
langages sont le standard pour la création de pages Web, et nous
voulons profiter de tous le bénéfices qu'offre la Web pour les
applications de type transactionnelle.

\item [Format pour échanger données:] Pour échanger les données
nous avons choisi XML. Le langage XML (eXtensible Markup Language)
nous permet de stocker, d'échanger et d'afficher des données ou de
l'information d'une manière structurée. Le langage permet aussi de
manipuler, de transformer et de visualiser les données avec de
nombreux outils de formatage, par exemple, des informations ou des
données stockées dans un document XML peuvent être affichées dans
un navigateur Web. De plus, quand des documents XML sont stockées
dans une base de données, ils peuvent être l'objet de requêtes et
retrouvés comme tout autre format de données.

\item [Langage pour coder la logique d'affaire:] Nous avons choisi
Java. Java est un langage interprété qui utilise la machine
virtuel Java (JVM). Il y a plusieurs versions de cette machine
virtuelle pour plusieurs plate-formes différentes, ce qui signifie
que les programmeurs peuvent écrire pour ce langage en utilisant
une plate-forme, et faire tourner leurs programmes sur autres.

\item [La persistance de données:] Pour l'implémentation de la
couche persistance de données nous avons choisi d'utiliser une
base de données. Une base de données est une entité dans laquelle
il est possible de stocker des données de façon structurée avec le
moins de redondance possible. Ces données doivent pouvoir être
utilisées par des programmes écrits en différents langages en
utilisant la technologie standard ODBC (Open DataBase
Connectivity), si nous utilisons Java comme langage pour établir
la connexion vers la base de données, nous pouvons utiliser JDBC
(Java Database Connectivity). Le standard JDBC est un programme
d'application (API) pour établir la connexion entre le langage
Java et un grande nombre de bases de données, en utilisant la
philosophie "Write Once, Run Anywhere".
\end{description}

Même si ce n'est pas la seule option pour l'implementation de
notre système de production d'horaires, nous sommes convaincus que
notre choix nous permettra de faire évoluer le système par
versions en ajoutant ou en modifiant caractéristiques demandés par
les institutions.


\section{Conclusions}\label{sec:conc}

Nous avons présenté une architecture pour la production d'horaires
dans une institution d'enseignement. Un objectif a guidé notre
démarche~: avoir une architecture ouverte et extensible. Dans la
présentation de l'architecture nous avons montré qu'elle possède
les deux qualités. Notre architecture est ouverte, étant donné
qu'elle accepte plusieurs instances. L'architecture est aussi
extensible, parce que nous pourrions changer les modules d'une
manière facile.


Nous arrivons à l'objectif de modéliser le processus de production
d'horaires pour prendre des décisions permettant son
automatisation. Ceci peut faciliter les développement et
l'implantation d'un système sur deux points de vue~:


\begin{itemize}

\item Le développement d'interfaces logiciels entre les différents
constituants du système, ceci peut conduire à développer de
nouveau modules ou à la modification de modules existants.

\item L'intégration graduelle de nouveaux modules dans le temps,
afin de perturber le moins possible les utilisateurs du système.
\end{itemize}

Dans le système que nous proposons, nous essayons de limiter le
plus possible d'intervention humaine afin de réduire des erreurs
de manipulation. Nous essayons de réduire aussi le sources
possible d'erreurs en vérifiant l'entrée de données.

Le travail futur est de continuer à concevoir le système au
complet en gardant les lignes directrices de extensibilité et
d'ouverture.

\bibliography{bibDiamant,bibProg}


\end{document}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\section{Glossaire}


\begin{description}

\item [Architecture logiciel:] "Abstractly, software architecture
involves the description of elements from which systems are built,
interactions among those elements, patterns that guide their
composition, and constraints on there patterns." \cite{shaw96}

\item [Architecture Ouverte:] "An architecture whose
specifications are public. This includes officially approved
standards as well as privately designed architectures whose
specifications are made public by the designers. The opposite of
open is closed or proprietary."
\footnote{http:\//\//www.webopedia.com\//TERM\//O\//open\_architecture.html}

\item [Portability] "Portability is the easy of transferring
software products to various hardware and software
environments."\cite{meyer97}

\item Architecture Modulaire Ouverte Extensible

\item [Architecture Extensible] "Extendibility is the easy of
adapting software products to change of specification."
\cite{meyer97}

\item [Reusability] "Reusability is the ability of software
elements to serve for the construction of many different
applications." \cite{meyer97}

\item [Compatibility] "Compatibility is the easy of combining
software elements with others." \cite{meyer97}

\item [Module]"A module is a work assignment for a programmer or
programmer team. Each module consists of a group of closely
related programs. The module structure is the decomposition of a
program into modules and the assumption that the team responsible
for each module is allowed to make about the other modules."
\cite{meyer97}

\end{description}
