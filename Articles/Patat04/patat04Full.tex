\documentclass{llncs}
\bibliographystyle{alpha}
\usepackage[T1]{fontenc}
\usepackage{dfd,hhline}
\usepackage{verbatim}
\setlength{\parskip}{1.5ex plus0.5ex minus0ex}

\newcommand{\ang}{\textsf}
\newcommand{\key}{\textsf}
\newcommand{\ita}{\textit}
\newcommand{\bld}{\textbf}
\newcommand{\dos}{\textsc}
\newcommand{\pro}{\texttt}

\newcommand{\saphir}{SAPHIR}
\newcommand{\diamant}{DIAMANT}
\newcommand{\tictac}{Tic-Tac}
\newcommand{\xp}{eXtreme Programming}
\def\eXit{$\epsilon$\kern-.100em \lower.5ex\hbox{X}\kern-.125emit}

\title{\bf{L'architecture d'un système de production des horaires
de cours et d'examens}}
\author{Ruben Gonzalez Rubio \\Domingo Palao Muñoz}
\institute{Département de génie électrique et de génie informatique \\
Université de Sherbrooke,\\
Sherbrooke, Québec, J1K 2R1 \\
Canada \\
\email{Ruben.Gonzalez-Rubio@USherbrooke.ca} \\
\email{Domingo.Palao@USherbrooke.ca}}
\date{}

%%%%%%%%%%%%%%%%%%
\pagestyle{plain} %% to be commented when sent
\newcommand{\ints}{\renewcommand{\baselinestretch}{1.0}\small\normalsize}
\newcommand{\intm}{\renewcommand{\baselinestretch}{1.5}\small\normalsize}
\newcommand{\intd}{\renewcommand{\baselinestretch}{2.0}\small\normalsize}
%%%%%%%%%%%%%%%%%%

\begin{document}

\maketitle

\intd

\begin{abstract} \label{intro}
\input{resume.tex}
\end{abstract}

{\bf Mots clés :}
Production d'horaires,
Construction d'horaires,
Architecture ouverte,
Architecture extensible,
Bases de données,
Web.

\section{Introduction}
La production d'horaires est une tâche périodique effectuée dans
beaucoup d'insti\-tutions d'enseignement.  Ces institutions
produisent un ou plusieurs horaires par année pour les cours et
les examens. L'automatisation de cette production peut réduire son
coût de manière importante. Dans certains cas, l'automatisation
commence par l'utilisation d'un logiciel de construction
d'horaires; dans d'autres cas l'automatisation  commence par les
traitements associés au fonctionnement de l'institution, comme par
exemple le suivi des étudiants. Il existe plusieurs des logiciels
pour effectuer la construction d'horaires, on peut citer comme
exemples DIAMANT \cite{gonzalezrubio00} et SAPHIR
\cite{ferland94}, mais, il en existe d'autres.

En général, les logiciels pour la création d'horaires utilisent
comme  entrée un ou plusieurs fichiers. Leur sortie est effectuée
également sur un ou plusieurs fichiers. Travailler avec des
fichiers est une sources de problèmes. Il faut cons\-trui\-re les
fichiers d'entrée à chaque fois qu'un horaire est produit. Il
existe deux cas~: une production manuelle des fichiers ou une
production automatisée. Si les fichiers sont produits
manuellement, les erreurs de frappe ou d'inattention peuvent
produire des effets inattendus dans le logiciel. Les erreurs sont
difficiles à détecter, car il faut vérifier toutes les données
manuellement. Dans le cas où les fichiers sont produits de manière
automatique, il faut que le logiciel s'assure de vérifier la
validité et la cohérence de toutes les données. Le deuxième
pro\-blème se manifeste lorsqu'un changement est introduit dans le
système (soit dans l'application de construction, soit dans celui
de la production de fichiers) ou si l'application de construction
est utilisé sur plusieurs sites différents, utilisant de formats
des données différents.

Une autre source de problèmes, encore plus coûteuse que la
précédente, est celle de l'introduction d'un changement dans le
système, soit dans le logiciel de construction, ou dans le
logiciel de la production ou bien dans les deux. Les changements
viennent de la part de responsables de l'institution, par exemple
une nouvelle nomenclature pour les locaux; nouvelle approche
pédagogique, qui change la constitution de groupes, etc. Ce
problème de modifier un logiciel n'est pas propre à la production
d'horaires. Il s'agit d'un problème général dans le développement
des logiciels.


La solution pour le premier problème passe par l'automatisation de
la vérification et de la, validation de données à la saisie des
données, afin d'assurer que le logiciel de construction travaille
sur les bonnes données. Le deuxième problème, est plus délicat à
traiter, si l'ensemble de logiciels de production ont été conçus
pour être modifiables (extensibles) le coût de faire une
modification sera faible, mais si le système est monolithique et
fermé une modification sera très coûteuse. Une manière de diminuer
les effets de ce problème est le développement de logiciel ayant,
entre autres, la qualité d'extensibilité.


Dans cet article nous proposons l'architecture  d'un système de
production des horaires de cours et des examens ayant les qualités
suivantes~: ouverture et extensibilité. Une telle architecture
doit contribuer à faire face plus facilement aux deux problèmes
mentionnés précédemment  en réduisant le coût des modifications et
en effectuant la vérification et la validation des données dans
des étapes précises du processus et en évitant la redondance du
code et des données. Cette architecture met en \oe{}uvre une base
de données, un site Web et un logiciel de construction. La
vérification et la validation de données  se font à l'entrée de
données et en appliquant des contraintes d'intégrité dans la base
de données.  Le site Web est utilisé principalement pour la saisie
de données, ceci permet de vérifier aussi la validité des données,
grâce aux règles d'affaires avant que la donnée soit entrée dans
la base. Une autre fonction du site Web est d'offrir les horaires
de manière personnalisé, une fois que l'horaire est construit. La
base de données permet l'extraction des données, selon différents
formats. Ainsi, l'entrée de données du logiciel de construction
est facilitée. Bien entendu, avec l'aide du logiciel de
construction d'horaires, il est possible de fabriquer un horaire
avec un minimum de conflits.


Des nombreuses recherches ont été faites dans la construction
d'horaires~: algorithmes et formulations mathématiques et
plusieurs logiciels ont été proposés dans les conférences PATAT
\cite{patat97,patat00,patat02}. Par contre, peu d'efforts ont été
consacrés jusqu'à présent au développement global de la production
d'horaires. Nous pensons que le fait d'avoir une vue globale sur
le processus peut aider la recherche en construction d'horaires.
White \cite{white00} a mis en évidence que le Web doit être
utilisé comme un moyen de diffusion d'horaires. Nous allons un peu
plus loin en proposant  de l'utiliser également comme interface
d'entrée, de plus nous proposons l'architecture nécessaire à
supporter nos idées. De Causmaecker et al \cite{decausmaecker02}
ont introduit l'idée que la sémantique du Web peut être utilisée
par les chercheurs en construction d'horaires. Ils ont aussi
introduit l'idée d'utiliser XML comme langage de communication
dans la construction d'horaires par agents. Nous proposons aussi
l'utilisation de XML, afin de faciliter les échanges entre
certains modules de notre architecture. Dans Burke et al.
\cite{burke97} il est proposé d'avoir un standard pour le format
de données pour des instances d'horaires, leur but était de
comparer des algorithmes (programmes) dans des ``benchmarks''.
Dans un travail plus récent, Kingston \cite{kingston02} propose un
language STTL et un interpréteur, avec le même objectif. Özcan
\cite{ozcan03} suggère aussi un autre standard pour définir des
instances de problèmes de construction d'horaires, ayant comme
base le langage XML. Il nous semble qu'il serait souhaitable
d'avoir un standard, mais c'est un but très difficile à atteindre.
À la place, notre approche permet d'utiliser une base de données
comme un outil d'extraction et de formattage, de cette manière le
logiciel de construction d'horaires peut recevoir les données
nécessaires. Ainsi, il serait possible de générer des instances de
problèmes pour d'autres logiciels de construction d'horaires.


Le développement de notre architecture a été divisé en deux
étapes.Nous avons analysé le flot des données dans un système
générique de production d'horaires. Ensuite nous avons défini
l'architecture, les blocs de base et la responsabilité de chaque
bloc qui participe dans l'architecture. Les objectifs de définir
une architecture ouverte et extensible ont été respectés pendant
nos travaux. Ceci est présenté dans les sections \ref{sec:data} et
\ref{sec:archi}.

Une fois l'architecture définie, nous avons créé une instance afin
de l'implanter dans un système de production d'horaires à
l'Université de Sherbrooke. Nous avons fait un survol des
technologies existantes afin de faire les bons choix respectant
encore les objectifs d'ouverture et d'extensibilité. Ceci est
présenté dans les sections \ref{sec:tech} et \ref{sec:tictac}.

Nous finissons par un bilan et des conclusions à la section
\ref{sec:conc}.



\section{Le flot de l'information dans la production d'horaires}
\label{sec:data}

Tout d'abord, nous définissons le processus de production
d'horaires comme un processus qui démarre lorsqu'on commence  la
saisie de données pour la période de validité de l'horaire $P$.
Cette période $P$ est un semestre, un  trimestre, ou une
année\footnote{À l'Université de Sherbrooke on parle de trimestre,
mais en réalité il comporte seize semaines (presque quatre mois),
donc le système doit s'adapter à toute période $P$.}. Le processus
est fini lorsque toutes les personnes concernées reçoivent
l'horaire sur un support papier ou sur une page Web (voir figure
\ref{fig:fOne}) et que la période de validité de l'horaire touche
à sa fin. Les données à saisir sont multiples, par exemple, les
cours qui vont avoir lieu dans la période $P$; le format du cours
(3h, ou 2h+1h); les enseignants possibles ou assignés à certains
cours; les locaux possibles ou assignées; la disponibilité des
enseignants et des locaux, etc.. Si\-gnalons qu'il existe des
institutions où les étudiants font un pré-choix et d'autres où les
horaires sont faits sans pré-choix. Le pré-choix des étudiants
fait partie des données à saisir, s'il n'y a pas de pré-choix, il
faut indiquer le nombre d'étudiants à admettre pour chaque cours.


\begin{figure}[htb] \begin{center}
\setlength{\unitlength}{0.1cm}
\begin{picture}(90,35)
\deffilebox{20}{10}{0.2}
\defprocessbox{20}{16}
\put(0, 15){\fichier[\pro{Données}]}

\put( 20,20){\vector(1,0){15}}

\put(35, 12){\process[Système de\\production \\ d'horaires]}

\put(55, 20){\vector(1,0){7}} \put(62, 20){\corner[y]{-10}{8}}
\put(62, 20){\corner[y]{10}{8}}

\put(70, 25){\fichier[\pro{Papier}]}

\put(70, 5){\fichier[\pro{Page Web}]}
\end{picture}
\end{center}
\caption{La production d'horaires}\label{fig:fOne}
\end{figure}

La figure \ref{fig:fOne} est une vue abstraite de la production
d'horaires, le système de production inclut un logiciel de
construction d'horaires.



\begin{description}
\item[Système de production d'horaires.] Il est composé de
plusieurs logiciels, ou modules, qui fonctionnent de manière
autonome, mais coordonnée. Il nous apparaît clair que  le système
doit avoir deux composantes principales~: le système de
sauve\-garde de données et le logiciel de construction d'horaires.

\item[Données.] Elles représentent les données nécessaires à la
production d'horaires. Nous allons sauvegarder toutes les données
nécessaires dans un système de sauve\-garde de données. Dans la
figure, il n'est pas indiqué que ces données peuvent être
manipulées par des modules du système de production d'horaires.
Par exemple, le module de saisie de pré-choix, va sauvegarder les
cours suivis par un étudiant. Le module de construction de données
va prendre son entrée dans l'entrepôt des données et lorsque la
construction sera faite les nouvelles données obtenues seront
remises dans l'entrepôt des données.


\item[Papier ou Page Web.] Il s'agit de la sortie du système une
fois que l'horaire est construit. Ces sorties peuvent être des
fichiers qui seront imprimés sur papier, ou des données qui seront
affichées sur une page Web, dans les deux cas les données sources
se trouvent dans  l'entrepôt des données.

\end{description}




\subsection{La préparation des données}
La figure \ref{fig:fTwo} montre l'évolution des données pendant la
production de l'horaire. L'évolution présente les instances des
données à différents instants du processus.

L'entrepôt des données peut représenter une seule ou plusieurs
bases de données, on peut penser à une base de données répartie.
Le choix de la base est un décision d'implémentation. De manière
conceptuelle il s'agit d'un seul entrepôt des données.

\begin{figure}[htb] \begin{center}
\setlength{\unitlength}{0.1cm}
\begin{picture}(90,40)
\deffilebox{20}{10}{0.2}
\defprocessbox{20}{16}
\put(0, 15){\fichier[$bd_{1}$]}

\put(0, 5){\makebox(20,10){Données de base}}

\put(20, 20){\vector(1,0){10}} \put(30, 15){\fichier[$bd_{2}$]}
\put(30, 5){\makebox(20,10){Données période $P$}}
\put(50,20){\vector(1,0){10}}

\put(60, 15){\fichier[$bd_{3}$]}

\put(60, 5){\makebox(20,10){Données horaire}}
\end{picture}
\end{center}

\caption{L'évolution des données pendant la production d'un
horaire}\label{fig:fTwo}
\end{figure}


\begin{description}
\item[Données de base.] Ces données sont les données définies à
long terme dans l'entrepôt.  L'information des activités
pédagogiques d'un programme, les programmes offerts, les
enseignants, les caractéristiques de salles de cours, les
étudiants sont des exemples de ce type d'information. Il s'agit en
général des informations qui sont partagées par d'autres
applications. Par exemple un étudiant est décrit par son nom,
prénom, matricule, programme suivi, etc. Une application qui
utilise les données étudiants est par exemple celle qui permet
d'imprimer les notes d'un étudiant sur son bulletin. Dans cet
article, nous nous intéressons uniquement aux données associées à
la production d'horaires, qui peut être une vue (une partie) de la
base de données complète de l'institution.


\item[Données période $P$.] Ces données sont nécessaires à la
construction d'un horaire pour la période concernée, elles
contiennent les cours qui seront offerts à cette période, la
disponibilité des enseignants pour cette période, etc. Ces données
sont un préalable à la construction d'un horaire et sont saisies
avant chaque construction. Cependant, ces données vont changer
(mises-à-jour) pendant la construction de l'horaire. Par exemple
lorsqu'on trouve un enseignant externe pour un cours donné, on
saisira des informations telles que son nom et sa disponibilité
dans la base.

\item[Données horaire.] Ces donnés sont le résultat de  la
construction de l'horaire. Elles vont contenir toutes les
informations nécessaires pour imprimer ou afficher des horaires
généraux et personnalisés.

\end{description}

En plus de la construction d'horaires de cours, le système doit
servir à cons\-truire les horaires d'examens. L'évolution de
données, dans le cas d'examens,  suit le même chemin que celui de
l'horaire de cours. Par contre  les données extraites de la base
peuvent être différentes, par exemple, pour un horaire d'examens
la disponibilité des enseignants peut ne pas être nécessaire.


Il existe deux grandes activités dans la production~: la saisie
(incluant les mises-à-jour) de données et  la construction de
l'horaire.



\begin{figure}[htb] \begin{center}
\setlength{\unitlength}{0.1cm}

\begin{picture}(90,40)
 \put(-6,7){ \shortstack{$b)$}}
 \put(0, 10){\vector(1,0){90}}
 \put(5,9){\line(0,1){2}}
 \put(4,7){\shortstack{$t_0$}}
 \put(85, 9){\line(0,1){2}}
 \put(84,7){\shortstack{$t_f$}}
 \put(5, 12){\vector(1,0){75}}
 \put(45, 14){\vector(1,0){40}}
 \put(9,13){ \shortstack{Saisie}}
 \put(54,16){ \shortstack{Construction}}
 \put(-6,22){ \shortstack{$a)$}}
 \put(0, 25){\vector(1,0){90}}
 \put(5, 24){\line(0,1){2}}
 \put(4,22){ \shortstack{$t_0$}}
 \put(5, 27){\vector(1,0){40}}
 \put(45, 27){\vector(1,0){40}}
 \put(85, 24){\line(0,1){2}}
 \put(84,22){\shortstack{$t_f$}}
 \put(9,28){ \shortstack{Saisie}}
 \put(54,28){ \shortstack{Construction}}
\end{picture}%}
\end{center}

\caption{Les activités de saisie et de construction pour une
période $P$}\label{fig:fTime}
\end{figure}

La figure \ref{fig:fTime} nous montre les deux cas de l'évolution
de ces activités. Dans le cas $a)$ la saisie et la construction
sont deux activités réalisées en séquence. Ceci représente le cas
idéal. Dans le cas $b)$ qui montre la réalité, la saisie (surtout
les mises-à-jour) se fait en même temps que la construction. Au
départ d'une construction, des données sont fixées, mais si le
logiciel ou le responsable ne trouvent pas une solution
satisfaisante il faut faire des changements même dans certains
données fixés.

The activities data input and construction can be carried out by
several of users. Each one has an associated role and privileges
to be able to change certain data.

Afin de simplifier, nous considérons deux types d'utilisateurs~:
le commis et le responsable de la construction. Le commis saisit
les informations dans la base de données, le responsable de la
construction de l'horaire  interagit avec le programme de
construction d'horaires.

Le commis va saisir ou mettre à jour  une donnée dans la base si
la donnée est valide,  elle est acceptée et entrée dans la base.
Par exemple, si la donnée attendue est un entier dans un
intervalle, et que la donnée entrée correspond à l'ensemble de
valeurs attendues  elle sera entrée dans la base. Sinon, le
système doit forcer le commis à rentrer une nouvelle valeur.

La construction d'horaires est une activité de nature itérative.
En général, les algorithmes de construction d'horaires proposent
de respecter les contraintes fortes et d'essayer de respecter le
plus possible de contraintes faibles, donc, le responsable va
essayer de trouver plusieurs solutions pour en choisir une. Dans
certains cas, il est possible de faire partir le programme avec
les mêmes données pour trouver une nouvelle solution, mais dans
d'autres cas il est  nécessaire de changer les données de départ
pour obtenir une nouvelle solution. S'il faut faire $n$ essais la
solution choisie par le responsable sera la solution $s$ où $1
\leq s \leq n$. Il est nécessaire de prévoir une manière de
travailler avec la base de données afin de sauvegarder les
changements effectuées pour chaque itération et faire un
``commit'' lorsque la solution est choisie et que l'horaire
devient définitif pour la période.




\section{L'architecture} \label{sec:archi}


Suite à l'étude du flot de données dans la production d'horaires,
nous sommes en mesure de proposer une architecture pour
implémenter le système.

\subsection{Une architecture pour la production d'horaires}

De manière abstraite, une architecture logicielle décrit les
éléments composants d'un système, elle montre aussi les
interactions entre ces éléments, les modèles qui guident sa
composition et les contraintes de ces modèles \cite{shaw96}.

De façon générale, quand nous avons un problème complexe, la
meilleure approche est de découper le problème en fragments qui
sont plus faciles à gérer avec des solutions simples. Par la
suite, si nous mettons ensemble ces petites solutions, nous allons
arriver à la solution de notre problème complexe
\cite{buschmann96}.

À l'heure actuelle il y a plusieurs architectures disponibles pour
développer des applications logicielles,  la plus adaptée pour le
système de production d'horaire est celle en couches.

L'architecture montrée dans la figure \ref{fig:fThree} propose la
division du système en trois couches, chacune avec une fonction
bien définie~:

\begin{description}
\item [L'interface.] Elle est responsable de présenter les données
à l'utilisateur, de permettre la saisie de données, ainsi que
d'assurer les échanges  avec d'autres systèmes.

\item [La couche de logique d'affaires.] Elle est responsable
d'assurer les échanges avec l'interface en validant et en
vérifiant les données saisies et en envoyant les données à
présenter dans un format adéquat. Elle assure aussi les échanges
avec la couche de persistance. Les règles d'affaires servent à
assurer la cohérence du système.

\item [La couche de persistance des données.] Elle gère le
stockage physique des données, soit dans des fichiers avec un
certain format, ou dans un système de gestion de bases de données
traditionnel ou bien dans d'autres modèles de persistance qui sont
capables de gérer des bases de données complexes.
\end {description}

\begin{figure}
\setlength{\unitlength}{1cm}
\begin{picture}(3,4.5)
  \put(3,4){\framebox(4,1){Interface}}
  \put(4.5,3.5){\vector(0,1){0.5}}
  \put(5.5,4){\vector(0,-1){0.5}}
  \put(3,2.5){\framebox(4,1){Logique d'affaires}}
  \put(4.5,2){\vector(0,1){0.5}}
  \put(5.5,2.5){\vector(0,-1){0.5}}
  \put(3,1){\framebox(4,1){Persistance de données}}
\end{picture}
\caption{L'architecture trois couches.}\label{fig:fThree}
\end{figure}


\subsection {L'architecture trois couches et le système de production d'horaires}


Pour chaque élément de l'architecture que nous avons présenté dans
la sous-section antérieure, nous proposons un composant qui fait
partie de l'application de production d'horaires. Dans cette
sous-section nous allons montrer l'intégration entre le flot des
données propre à un système de production d'horaires et
l'architecture proposée.

La conception de haut niveau de notre système de production
d'horaires est simple (voir figure \ref{fig:fOne})~:

\begin{enumerate}
\item Nous avons défini trois catégories de  données  dans un
système de production. La figure \ref{fig:fTwo} montre ces
catégories. La couche d'interface  traite ces données de la
manière suivante~:

\begin{enumerate}

\item Les données  de base. Ces données se trouvent dans une base
de données appartenant à l'institution. Cette base peut avoir ses
propres interfaces pour la saisie et l'affichage de données. Le
système de production a besoin d'une partie de ces données. Il est
nécessaire d'avoir une interface avec d'autres systèmes, sa
responsabilité est de chercher les données nécessaires et de
sauvegarder ces données dans le système de production. À noter que
pour des raisons de sécurité, les utilisateurs du système  ne
doivent pas avoir le droit de modifier les données de
l'institution.

\item La saisie directe des données d'une période $P$. Cette
activité est faite par un commis. Normalement, ces données
changent à chaque création d'un horaire. Pour saisir les données,
l'utilisateur commis a une page Web qui est affichée par un
navigateur où il aura des champs à remplir. À cette étape, la
couche d'interface peut faire quelques validations minimales de la
cohérence de données, par exemple, vérifier que le type de données
est correct, vérifier que les champs qui sont obligatoires sont
remplis, etc. Dépendant de la taille de l'institution, il peut
avoir plusieurs commis qui travaillent en même temps dans
l'application, il faut en conséquence, prendre les mesures
nécessaires pour permettre le travail concurrent dans la couche de
persistance de données.



\item Les données de l'horaire sont créées par l'application de
création d'horaires. Cette application est gérée par l'utilisateur
responsable de la création d'horaires. Étant donné que cette
activité est de nature itérative, il peut avoir un certain nombre
de versions de travail que l'utilisateur responsable de la
création d'horaires doit analyser pour trouver celle qui lui
convient le mieux. Une fois qu'il a trouvé cette version, il doit
appliquer l'opération "commit" pour rendre disponible
l'information au reste des utilisateurs. Ce sont les données qui
sortent du système. Ces données sont envoyées vers d'autres
systèmes ou bien vers d'autres utilisateurs. Par exemple, les
étudiants vont recevoir un papier avec leur horaire personnalisé
ou bien, ils peuvent consulter cette information en utilisant un
site Web crée pour ces fins.

\end{enumerate}

Il faut prendre en considération que la couche d'interface
communique uniquement avec la couche de logique d'affaires. Une
application n'est pas capable d'ajouter, modifier ou effacer des
données directement dans la base de données, elle doit passer
obligatoirement par la couche de logique d'affaires. Cette
caractéristique nous permet d'assurer la cohérence des données.

\item Les données sont traitées selon certaines règles et
contraintes, ces règles sont définies par chaque institution et
elles sont appliquées par la couche logique d'affaires. C'est ici
que nous pourrons exprimer des contraintes propres à chaque
institution, par exemple, la quantité maximale d'étudiants dans un
groupe, tous les cours de mathématique se déroulent le matin, etc.

\item Les données résultats de ces traitements doivent être
stockées dans quelque part pour pouvoir être utilisées après leur
génération. C'est la couche de persistance de données qui est
responsable de cette tâche. Dans un système de production
d'horaires, les données peuvent être stockées dans une base de
données (relationnel, objet ou autre technologie), dans un fichier
XML, dans un fichier texte ou bien dans autre moyen de stockage
pertinent.
\end{enumerate}

Ces éléments de composition et leur relations sont illustrés dans
la figure \ref{fig:fFour}.

\begin{figure}
\setlength{\unitlength}{0.5cm}
\begin{picture}(19,7)

  \put (0,6){\line(1,0){22}}
  \put (19,6.5){\makebox(0,0){\scriptsize Couche d'interface}}
  \put(0,6.5){\framebox(4,1){\tiny Saisie de données}}
  \put(2,6.65){\makebox(0,0){\tiny (Client Web)}}
  \put(5,6.5){\framebox(4,1){\tiny Création d'horaires}}
  \put(7,6.65){\makebox(0,0){\tiny (Interface)}}
  \put(10,6.5){\framebox(4,1){\tiny Autres systèmes}}
  \put(12,6.65){\makebox(0,0){\tiny (Interface)}}
  \put (2,6.5){\vector(1,-1){2}} %SD -> SW
  \put (4,4.5){\vector(-1,1){2}} %SW -> SD
  \put (7,6.5){\vector(-1,-1){2}} %CH -> SW
  \put (5,4.5){\vector(1,1){2}} %SW -> CH
  \put (7,6.5){\vector(1,-1){2}} %CH -> RA
  \put (9,4.5){\vector(-1,1){2}} %RA -> CH
  \put (12,6.5){\vector(-1,-1){2}} %AS -> RA
  \put (10,4.5){\vector(1,1){2}} %RA -> AS


  \put (0,3){\line(1,0){22}}
  \put (19,3.5){\makebox(0,0){\scriptsize Couche de logique d'affaires}}
  \put (2,3.5){\framebox(4,1){\tiny Serveur Web}}
  \put (8,3.5){\framebox(4,1){\tiny Règles d'affaires}}
  \put (6,4){\vector(1,0){2}} %RA -> SW
  \put (8,4){\vector(-1,0){2}} %SW -> RA
  \put (10,3.5){\vector(-1,-1){2}} %RA -> BD
  \put (8,1.5){\vector(1,1){2}} %BD -> RA


  \put (0,0){\line(1,0){22}}
  \put (19,0.5){\makebox(0,0){\scriptsize Couche de persistance des données}}
  \put (5,0.5){\framebox(6,1){\tiny Serveur Base Données}}

\end{picture}
\caption{L'implémentation de l'architecture trois couches pour le
système de production d'horaires.}\label{fig:fFour}
\end{figure}


\section{Technologies possibles}\label{sec:tech}

Pour l'implémentation de l'architecture, il faut en premier lieu,
faire un survol  des éléments technologiques nécessaires. Les
besoins sont~:

\begin{enumerate}
\item Un langage pour faciliter l'affichage des données vers
l'utilisateur ainsi que pour créer des formulaires pour saisir des
données.

\item Un ensemble de règles qui définissent la manière d'établir
l'échange des données avec les autres systèmes.

\item Un langage pour coder la logique d'affaires.

\item Un outil pour gérer la persistance des données.
\end{enumerate}

Après  analyse, nous avons constaté qu'il n'y a pas qu'une seule
option, plutôt il y a plusieurs possibilités pour implémenter
cette architecture.

Dans le Tableau \ref{tb:tbOne}, nous montrons une liste
d'instances possibles, il faut remarquer qu'elle n'est pas
exhaustive.

\begin{table}
\begin{tabular}{|c||c|c|c|}\hline
Technologie & Instance 1 & Instance 2 & Instance 3\\ \hline\hline
Langage pour affichage & HTML et JSP& Applet Java & Visual Basic\\
\hline Format pour échanger les données & XML & Text & Text\\
\hline

Langage pour coder la logique d'affaires & Java & Java & Visual Basic\\
\hline

La persistance de données & Base de données & Base de données & Base de données \\
\hline
\end{tabular}
~ \\
 \caption{ Quelques instances possibles de
l'architecture}\label{tb:tbOne}
\end{table}

Pour la construction de chaque instance  nous avons mis ensemble
les éléments qui ont des caractéristiques communes ou bien qui
appartiennent à une même famille de logiciels et qui sont ouverts.

Pour le volet base de données, nous n'avons pas mentionné le nom
spécifique d'un système de gestion de base de données, le choix
reste ouvert à l'implémentation.

Notre architecture est ouverte, étant donné qu'elle accepte
plusieurs instances. L'architecture est aussi extensible, parce
que nous pourrions changer les modules d'une manière facile, par
exemple, nous pouvons commencer avec un élément de persistance de
données comme un fichier en format texte plain, et après, nous
pourrions effectuer quelques changements dans l'élément
d'interface pour pouvoir interagir avec des fichiers en format
XML. Ensuite, si nous voulons faire évoluer cette partie de
persistance de données vers un système de base de données, il
faudrait faire des changements dans la couche d'interface et
programmer l'élément de persistance des données. Tous ces
changements doivent être effectués sans jamais toucher l'élément
de la logique d'affaires. Dans le Tableau \ref{tb:tbTwo}, nous
montrons l'évolution possible d'une instance de notre
architecture.

\begin{table}
\begin{tabular}{|c||c|c|c|}\hline
Technologie & Version 1 & Version 2 & Version 3\\ \hline\hline
Langage pour affichage & HTML et JSP & HTML et JSP & HTML et JSP\\
\hline

Format pour échanger les données & Text & XML & SQL, Base de données\\
\hline

Langage pour coder la logique d'affaires & Java & Java & Java\\
\hline

La persistance de données & Text & XML & SQL, Base de données \\
\hline

\end{tabular}
~ \\

\caption{ L'évolution d'une instance de
l'architecture}\label{tb:tbTwo}
\end{table}

Nous pouvons aussi imaginer un système qui commence avec un
interface basé en affichage en mode textuel, qui va évoluer à un
affichage basé en HTML et JSP en utilisant un serveur Web et un
serveur JSP.

\section{Une instance de l'architecture} \label{sec:tictac}

Une fois que nous avons établi l'architecture et que nous savons
qu'elle est ouverte et extensible, il faut que l'instance que nous
allons implémenter soit aussi ouverte et extensible. Nous avons
montré trois options d'instances de l'architecture (voir Tableau
\ref{tb:tbOne}), pour notre implémentation, nous avons choisi
l'option 1 de ce tableau.

Dès le départ, il faut savoir qu'un élément est ouvert s'il est
construit avec des standards approuvés, ou bien, s'il est
construit avec une spécification privée mais rendue publique par
les développeurs.
\footnote{http:\//\//www.webopedia.com\//TERM\//O\//open\_architecture.html}


Il faut aussi tenir  compte qu'un élément est extensible s'il est
facile d'adapter ce produit aux changements dans la spécification
\cite{meyer97}.



Avec ces considérations en main, nous montrons ici l'analyse qui
nous a amené à notre choix:

\begin{description}

\item [Langage pour affichage.] Pour langage d'affichage et saisie
de données nous avons choisi HTML et JSP, étant donné que ces
langages sont le standard pour la création de pages Web, et nous
voulons profiter de tous les bénéfices qu'offre un site Web pour
les applications de type transactionnelle.

\item [Format pour l'échange de données.] Pour échanger les
données nous avons choisi XML. Le langage XML (eXtensible Markup
Language) nous permet de stocker, d'échanger et d'afficher des
données ou de l'information d'une manière structurée. Le langage
permet aussi de manipuler, de transformer et de visualiser les
données avec de nombreux outils de formatage, par exemple, des
informations ou des données stockées dans un document XML peuvent
être affichées dans un navigateur Web. De plus, lorsque des
documents XML sont stockés dans une base de données, ils peuvent
être l'objet de requêtes et retrouvés comme tout autre format de
données.

\item [Langage pour coder la logique d'affaires.] Nous avons
choisi Java. Java est un langage interprété qui utilise la machine
virtuelle Java (JVM). Il y a plusieurs versions de cette machine
virtuelle pour plusieurs plate-formes différentes, ce qui signifie
que les programmeurs peuvent écrire pour ce langage en utilisant
une plate-forme, et faire tourner leurs programmes sur autres.

\item [La persistance de données.] Pour l'implémentation de la
couche persistance de données nous avons choisi d'utiliser une
base de données. Une base de données est une entité dans laquelle
il est possible de stocker des données de façon structurée avec le
moins de redondance possible. Ces données doivent pouvoir être
utilisées par des programmes écrits en différents langages en
utilisant la technologie standard ODBC (Open DataBase
Connectivity), si nous utilisons Java comme langage pour établir
la connexion vers la base de données, nous pouvons utiliser JDBC
(Java Database Connectivity). Le standard JDBC est un programme
d'application (API) pour établir la connexion entre le langage
Java et un grande nombre de bases de données, en utilisant la
philosophie "Write Once, Run Anywhere".
\end{description}

Même si ce n'est pas la seule option pour l'implémentation de
notre système de production d'horaires, nous sommes convaincus que
notre choix nous permettra de faire évoluer le système par
versions en ajoutant ou en modifiant les caractéristiques
demandées par les institutions.

L'implémentation technologique semble complexe. Il y a plusieurs
composants technologiques à utiliser. Mais, il faut savoir que
nous sommes en train de reprendre plusieurs modules existants.
C'est cela un des avantages d'avoir une architecture et une
instance ouverte et extensible. Nous pouvons analyser par couche
les composantes à réutiliser et ceux à implémenter :

\begin{description}

\item [Couche Interface.] Pour cette couche, il y a un élément
technologique qui peut faciliter énormément le travail, le
navigateur Web. Cet outil est disponible dans la plupart des
ordinateurs qui ont accès à l'Internet. Il faut alors, centraliser
les efforts en développer des pages Web avec la qualité de
compatibilité, nous avons entre autres Internet Explorer
\footnote{ http:\//\//www.microsoft.com}, Netscape \footnote{
http:\//\//www.netscape.com}, Mozilla \footnote{
http:\//\//www.mozilla.org}, etc.

La question maintenant est savoir comment assurer cette
compatibilité ? Il y a des efforts pour promouvoir l'utilisation
des standards de programmation HTML. Par exemple, la campagne "
Visible avec n'importe quel navigateur " \footnote{
http:\//\//www.anybrowser.org \//campaign/} préconise cette
philosophie. Le site Internet http://validator.w3.org/, offre un
outil d'analyse de compatibilité avec le standard HTML pour les
sites Web, cet outil est fourni par le " World Wide Web Consortium
" \footnote{ http:\//\//www.w3.org/} .

\item [Couche Logique d'affaires.] Il y a deux éléments
technologiques fondamentaux dans cette couche, un serveur Web et
un serveur capable de déployer la logique d'affaires. Étant donné
que nous avons choisi Java pour coder la logique d'affaires, nous
pouvons utiliser comme serveur Web Apache HTTP \footnote{
http:\//\//www.apache.org} et comme serveur pour fournir la
logique d'affaires Jakarta-Tomcat \footnote{
http:\//\//jakarta.apache.org}.

Le projet serveur HTTP d'Apache est un effort de développer et
maintenir un serveur d'HTTP ouvert ainsi que " Open source " pour
les systèmes d'exploitation plus utilisés comme UNIX et Windows.
Le but de ce projet est de fournir un serveur sécurisé, efficace
et extensible capable de fournir des services HTTP selon les
normes HTTP courantes.

Nous allons programmer les règles d'affaires dans quelques petits
programmes JAVA appelés servlets. Un servlet est un programme JAVA
utilisé pour étendre les fonctionnalités d'un serveur Web. Un
servlet est un programme utilisé pour générer du contenu dynamique
des applications. C'est une application exécutée dans le serveur
qui est téléchargé dynamiquement quand elle est demandée.
Jakarta-Tomcat est un conteneur de servlet.

Nous pouvons dire que le couple Apache et Jakarta-Tomcat nous
permettent de faire le déploiement d'un Web application complet.


\item [Couche Persistance de données.] Pour la couche de
persistance de données nous avons dit que nous avons allons
profiter de l'utilisation de JDBC (Java Database Connectivity). Le
JDBC se base sur l'utilisation d'un pilote pour donner l'accès à
plusieurs bases de données, l'avantage est que nous pouvons
changer le pilote selon le fournisseur de base de données
sélectionné. Pour le choix de la base de données nous avons dit
que c'était ouvert à l'implémentation, mais il faut toujours
chercher les standards, alors, le standard plus récemment publié
par l'ANSI (American National Standards Institute) pour le langage
qui traite l'information d'une base de données est SQL-99
\footnote{ http:\//\//web.ansi.org}. Ce standard est utilisé par
les plus importants développeurs de bases de données comme Oracle,
Informix, IBM-DB2, Cloudscape, PostgreSQL, et autres.

Tel que nous avons regardé dans cette section, nous profitons de
plusieurs éléments technologiques ouverts qui nous permettent de
rester ouverts et extensibles.

\end{description}



\section{Conclusion}\label{sec:conc}

Nous avons présenté l'architecture d'un système de production
d'horaires dans une institution d'enseignement. Un objectif a
guidé notre démarche~: avoir une architecture ouverte et
extensible afin d'assurer une vie plus longue au système.

Nous avons commencé par montrer les besoins d'échanges
d'information d'un tel système afin de mieux présenter comment
l'architecture est capable de sa\-tisfaire ces besoins. De plus,
dans la présentation de l'architecture nous avons montré qu'elle
possède les deux qualités. Notre architecture est ouverte~: il est
possible de construire plusieurs instances. L'architecture est
aussi extensible, parce que nous pourrions changer les modules
d'une manière facile. Les responsabilités de chaque module étant
définies, il est possible  d'identifier la partie du système
affectée par une modification. Il est nécessaire de continuer les
développements en continuant à avoir comme objectif l'ouverture
(compatibilité) et l'extensibilité dans tout le logiciel.

Il est maintenant possible de répondre à la question~: Est-ce que
la construction d'horaires peut bénéficier de développements
associés à la production d'horaires? Notre expérience dans le
développement de logiciels de construction d'horaires nous a
montré que~: la plupart des problèmes dans le logiciel viennent du
fait que les données en entrée ont des erreurs. Le logiciel de
construction doit dédier une grosse partie de son code pour
détecter ces erreurs. De plus, les utilisateurs prennent un temps
important pour vérifier la cohérence de données avant de commencer
le travail de construction. Alors, la réponse est oui, il existe
des bénéfices. En développant un système de production il est plus
facile d'assurer que le logiciel de construction a comme
responsabilité la construction de l'horaire et non celle de
vérification de données.

D'autres bénéfices sont aussi à envisager, comme par exemple
consulter son horaire par le Web (à jour) depuis sa residence,
surtout dans des pays où parfois il fait $-30^\circ$ et moins,
cela est bien apprécié.





\bibliography{bibDiamant,bibProg}


\end{document}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\section{Glossaire}


\begin{description}

\item [Architecture logiciel:] "Abstractly, software architecture
involves the description of elements from which systems are built,
interactions among those elements, patterns that guide their
composition, and constraints on there patterns." \cite{shaw96}

\item [Architecture Ouverte:] "An architecture whose
specifications are public. This includes officially approved
standards as well as privately designed architectures whose
specifications are made public by the designers. The opposite of
open is closed or proprietary."
\footnote{http:\//\//www.webopedia.com\//TERM\//O\//open\_architecture.html}

\item [Portability] "Portability is the easy of transferring
software products to various hardware and software
environments."\cite{meyer97}

\item Architecture Modulaire Ouverte Extensible

\item [Architecture Extensible] "Extendibility is the easy of
adapting software products to change of specification."
\cite{meyer97}

\item [Reusability] "Reusability is the ability of software
elements to serve for the construction of many different
applications." \cite{meyer97}

\item [Compatibility] "Compatibility is the easy of combining
software elements with others." \cite{meyer97}

\item [Module]"A module is a work assignment for a programmer or
programmer team. Each module consists of a group of closely
related programs. The module structure is the decomposition of a
program into modules and the assumption that the team responsible
for each module is allowed to make about the other modules."
\cite{meyer97}

\end{description}
