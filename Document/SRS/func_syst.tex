\chapter{Fonctionnalités du système}

Ce chapitre permet de décrire avec plus de détails, les
fonctionnalités présentées à la section \ref{spec_prod}.


    \section{Affectation de locaux}\label{aff_locaux}

     Cette fonctionnalité permet d'assigner de façon optimale des
     locaux aux événements.

        \subsection{Description et priorité}

        Le but de cette fonctionnalité est de placer le maximum
        d'étudiants dans le plus petit local pour chaque période de la
        journée.


        \subsection{Séquences stimulis/réponses}

        % List the sequences of input stimuli (user actions, signals from
        % external devices, or other triggers) and system responses that
        % define the behaviors for this feature. These stimuli correspond to
        % the initial dialog steps of use cases or to external system
        % events.

        L'utilisation de cette fonctionnalité se fera à travers trois
        interfaces: le menu d'affectation de locaux, le dialogue
        d'événements et le dialogue d'option de conflits. Cette
        fonctionnalité va entrainer un refactoring des événements et
        de préférences afin que ceux-ci integrent les nouveaux champs
        dans les lectures, écritures et traitements.

            \subsubsection{Les sous-menus affectation de locaux, affectation d'événements et option de conflits}

            Les nouveaux sous-menus (Affectation de locaux,
            Affectation d'événements et Option de conflits) devront
            être placés sous le menu
            \verb!BetaTest --> Fonctionnalités v 1.6.2! comme présenté
            sur la figure \ref{menu_feat}.

            \begin{figure*}[h]
            % Requires \usepackage{graphicx}
                \begin{center}
                \includegraphics[width=6.0in]{SRS/images/menu_feat_1-6-2.eps}
                \caption{Menu des fonctionnalités de la version 1.6.2}\label{menu_feat}
                \end{center}
            \end{figure*}

            \subsubsection{Le dialogue d'événements }

            Le nouveau dialogue d'événements devra intégrer la
            fonction et l'état du local comme présenté par la figure
            \ref{dlg_event}.

            \begin{figure*}[h]
            % Requires \usepackage{graphicx}
                \begin{center}
                \includegraphics[width=6.0in]{SRS/images/dlg_event.eps}
                \caption{Dialogue d'affectation d'événements de la version 1.6.2}\label{dlg_event}
                \end{center}
            \end{figure*}

            \subsubsection{Le dialogue d'option de conflits }

            Le nouveau dialogue d'option de conflits devra intégrer un
            champ permettant de spécifier le taux d'occupation désiré
            pour les locaux comme présenté par la figure
            \ref{dlg_conf}.

            \begin{figure*}[h]
            % Requires \usepackage{graphicx}
                \begin{center}
                \includegraphics[width=6.0in]{SRS/images/dlg_conflicts.eps}
                \caption{Dialogue d'option de conflits de la version 1.6.2}\label{dlg_conf}
                \end{center}
            \end{figure*}

            \subsubsection{Refactoring des événements}

            Étant donné que les événements devront intégrer de
            nouveaux champs (fonction et état), il sera necessaire
            d'effectuer les tâches suivantes:

            \begin{itemize}
                \item Refactoring de l'ensemble des événements afin
                      d'intégrer les champs fonction et état du local
                      dans un événement.
                \item Refactoring de l'ensemble des activités afin de
                      permettre, d'une part, l'intégration des champs
                      fonction et état du local, et d'autre part, la
                      lecture et la sauvegarde des nouveaux champs.
                \item Création d'un nouvel ensemble contenant la liste
                      des fonctions de locaux disponibles.
            \end{itemize}

            \subsubsection{Refactoring des préférences}
            Faire le refactoring des préférences afin d'y intégrer le
            nouveau champ (taux de remplissage des locaux).

        \subsection{Requis fonctionnels}

        De nombreux attributs doivent être pris en compte dans cette
        affectation.

            \subsubsection{Attributs des événements }

            \begin{itemize}
                \item Le nom de l'événement: l'identifiant unique de
                      l'événement.
                \item L'horaire: la ou les périodes dans lesquelles
                      l'événement est placé.
                \item Le nombre d'étudiants participant à l'événement.
                \item L'identifiant du local associé.
            \end{itemize}

            \subsubsection{Attributs des locaux }
            \begin{itemize}
                \item Le nom du local: l'identifiant unique du local.
                \item La capacité du local: nombre de sièges
                      disponibles dans le local.
                \item La catégorie du local.
                \item La fonction du local.
                \item L'état du local: le local est figer dans une
                      période et par conséquent il ne peut plus faire
                      l'objet d'une affectation.
            \end{itemize}

            \subsubsection{Contraintes d'optimisation }
            \begin{itemize}
                \item Faire une affectation en tenant compte du taux
                      de remplissage des locaux.
                \item Faire une affectation en tenant compte de la
                      catégorie et de la fonction des locaux.
                \item Faire une affectation en tenant compte de la
                      capacité des locaux.
                \item Assigner un nouveau local à un événement si et
                      seulement si cet événement n'est figé dans aucun
                      local (état figé du local).
                \item L'algorithme devra assigner des locaux aux
                      événements placés dans chaque période de la
                      grille.
                \item L'algorithme devra faire une assignation de
                      sorte à avoir le maximum d'étudiants d'un
                      événement donné dans le plus petit local
                      disponible.
            \end{itemize}

            \subsubsection{Spécification de l'algorithme d'affectation de locaux}

            L'affectation de locaux est un problème d'optimisation,
            dans lequel on cherche à construire une solution à un
            problème qui optimise une fonction objectif.

            Ce problème d'optimisation peut se poser comme suit:

            \begin{enumerate}
                \item pour une instance I (par exemple: les horaires
                      des cours à assurer, des locaux à affecter),
                \item trouver une solution (par exemple une
                      affectation de local à chaque cours),
                \item qui vérifie les contraintes (par exemple, il n'y
                      a pas deux cours en même temps dans un local...,
                      le nombre d'étudiants suivant un cours est < ou
                      = à la capacité du local dans lequel ce cours va
                      se donner),
                \item et qui optimise une fonction objectif (par
                      exemple, minimise le nombre de locaux).
            \end{enumerate}


            Pour résoudre ce problème d'optimisation, nous utiliserons
            la méthode gloutonne (algorithme glouton - greedy
            algorithm) en construisant tout simplement la solution
            incrémentalement, en rajoutant à chaque pas un élément
            selon un critère glouton, c'est à dire celui qui nous
            paraît «localement» le meilleurun choix à «court terme».

            \begin{description}
                \item[Le problème: ] On est dans le cadre de problèmes
                     d'optimisation.  Plus précisément, on est le plus
                     souvent dans le cas suivant:
                \begin{itemize}
                    \item On a un ensemble fini d'éléments, E.
                    \item Une solution à notre problème est construite
                          à partir des éléments de E: c'est par
                          exemple une partie de E ou un multi-ensemble
                          d'éléments de E ou une suite (finie)
                          d'éléments de E ou une permutation de E qui
                          satisfait une certaine contrainte.
                    \item A chaque solution S est associée une
                          fonction objectif v(S): on cherche donc une
                          solution qui maximise (ou minimise) cette
                          fonction objectif.
                \end{itemize}
                \item[Le schéma de la méthode: ] Il est basé sur un
                     critère local de sélection des éléments de E pour
                     construire une solution optimale. En fait, on
                     travaille sur l'objet " solution partielle"-
                     "début de solution"- et on doit disposer de:
                \begin{itemize}
                    \item select: qui choisit le meilleur élément
                          restant selon le critère glouton.
                    \item complete? qui teste si une solution
                          partielle est une solution (complète).
                    \item ajoutPossible? qui teste si un élément peut
                          être ajouté à une solution partielle,
                          i.e. si la solution partielle reste un début
                          de solution possible après l'ajout de
                          l'élément.  Dans certains cas, c'est
                          toujours vrai!
                    \item ajout qui permet d'ajouter un élément à une
                          solution si c'est possible.
                \end{itemize}
                \item[L'algorithme est alors: ]

                \begin{verbatim}
                //on va construire la solution dans Sol
                //initialisation
                Ens=E;
                Sol.Init //= ensemble (ou suite) "vide" ou..
                tant que Non Sol.Complete?() ( et Ens.NonVide?())
                select(x,Ens); //on choisit x selon critère glouton
                si Sol.AjoutPossible(x) alors Sol.Ajout(x); fsi;
                //dans certains problèmes, c'est toujours le cas
                si CertainesConditions alors Ens.Retirer(x);
                //selon les cas, x ne sera considéré qu'une fois
                // ou jusqu'à qu'il ne puisse plus etre ajouté
                fin tant que;
                //la Solution partielle est complète ...normalement
                retourne Sol
                \end{verbatim}
            \end{description}
