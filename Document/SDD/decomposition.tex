\chapter{Description de la décomposition}
Le logiciel \dx{} pour fonctionner à besoin de la machine virtuelle Java. Pour construire un horaire \dx{} a besoin d'un ensemble de fichiers. Le déploiement de \dx{} devrait donc se faire en considérant les deux autres entités dont il a besoin (voir figure \ref{datastruct}).

\begin{figure*}[h]
  % Requires \usepackage{graphicx}
  \begin{center}
    \includegraphics[width=350pt]{SDD/images/Deploiement-global.eps}
    \caption{Système \dx{}}\label{datastruct}
  \end{center}
\end{figure*} 
\section{Description des fichiers d'entrée de  \diamant{}}
\dx{} utilisent les fichiers suivantes~:

\begin{enumerate}
    \item Étudiants.
    \item Instructeurs.
    \item Activités.
    \item Locaux
\end{enumerate}

Les trois premiers sont produits au STI (Système informatique
central) et transférés via FTP.
Le fichier de locaux est produit
localement par l'utilisateur.

Tous les fichiers ont un format très
rigide. Le nombre de caractères et leur position est à respecter
obligatoirement.

Les indexes de chaînes de caractères commencent à \verb!0!.
\input{SDD/inputData}

\section{Décomposition modulaire (Modèle Objet)} \label{module}

\subsection{Choix du modèle}

\subsubsection{Contexte} 
    L'objectif de la majorité des systèmes informatiques est de récupérer les données d'un entrepôt de données (fichiers, base de données) et de les présenter à l'utilisateur. Une fois que l'utilisateur a modifié les données, le système stocke les mises à jour dans l'entrepôt. Comme le principal flux d'informations s'effectue entre l'entrepôt de données et l'interface utilisateur, nous pourrions être tenté de lier ces deux éléments afin de réduire le volume de code et améliorer les performances de l'application. 

Cette approche qui peut nous paraître naturelle n'est pas sans présenter certains problèmes non négligeables. L'un d'eux est que l'interface utilisateur a tendance à changer plus fréquemment que le système de stockage des données. Autre problème du couplage des données avec les éléments d'interface utilisateur, les applications métier tendent à intégrer une logique métier qui va bien au-delà de la transmission de données.

\subsubsection{Problème}
Comment rendre modulaire l'interface utilisateur d'une application de sorte que chaque partie puisse être aisément modifiée individuellement?

\subsubsection{Facteurs à prendre en compte}
Les facteurs suivants agissent sur le système dans le contexte présent et doivent être pris en compte dans la recherche de la solution au problème :

\begin{itemize}
    \item  La logique d'interface utilisateur est modifiée plus fréquemment que la logique métier. Il est possible, par exemple, d'ajouter de nouvelles fenêtres d'interface ou de réorganiser les fenêtres existantes. Si le code de présentation et la logique métier sont associés dans un seul et même objet, vous devrez modifier l'objet contenant la logique métier chaque fois que vous souhaiterez changer l'interface utilisateur. Cette démarche risque d'introduire des erreurs et nécessite à chaque modification de l'interface, même minime, de tester de nouveau l'ensemble de la logique métier.\\
    \item  Dans certains cas, l'application affiche les mêmes données sous plusieurs formes. Par exemple, un analyste préférera visualiser les données dans une feuille de calcul alors que ses managers choisiront les graphiques à secteur pour afficher les mêmes données. Certaines interfaces utilisateur clientes riches présentent simultanément plusieurs vues des mêmes données. Si l'utilisateur modifie les données dans une vue, le système doit mettre à jour automatiquement toutes les autres vues des données.\\
    \item  La conception d'interfaces visuellement efficaces et attirantes nécessite généralement des compétences autres que celles requises pour le développement d'une logique métier complexe. Et il est bien rare qu'une même personne présente cette double compétence. Il est donc préférable de séparer l'effort de développement de ces deux parties.\\
    \item  L'activité de l'interface utilisateur se compose généralement de deux éléments : la présentation et la mise à jour. La partie présentation récupère les données d'un entrepôt de données et les met en forme avant de les afficher. Lorsque l'utilisateur effectue une action sur les données, la partie mise à jour passe la main à la logique métier pour mettre à jour les données.\\
    \item  Le code de l'interface utilisateur dépend généralement plus de la machine que la logique métier. Si vous souhaitez faire migrer l'application d'une application monolithique à une application sur navigateur ou à une application sur assistant personnel ou sur téléphone mobile compatible Web, vous devez réécrire une bonne partie du code de l'interface utilisateur alors que la logique métier pourra rester inchangée. Une séparation claire de ces deux éléments permet d'accélérer la migration et de réduire le risque d'introduction d'erreurs dans la logique métier.\\
    \item  La création de tests automatisés pour les interfaces utilisateur est généralement plus longue et difficile que les mêmes tests pour la logique métier. On comprend donc que réduire le volume de code directement lié à l'interface utilisateur permet d'améliorer les capacités d'évaluation de l'application.\\
\end{itemize}    
  

\subsubsection{Solution}

\dx{} est une application GUI\footnote{Graphical User Interface}. Sa construction requiert donc l'utilisation d'un modèle adapté: le modèle Model-View-Controller (MVC), car il sépare la modélisation du domaine, la présentation et les actions reposant sur l'entrée utilisateur en trois composant distincts :



\begin{figure*}[h]
  % Requires \usepackage{graphicx}
  \begin{center}
    \includegraphics[width=350pt]{SDD/images/Deploiement-diamant.eps}
    \caption{Architecture MVC de \dx{}}\label{datastruct}
  \end{center}
\end{figure*} 

\begin{description}
    \item[Le modèle:] il gère le comportement et les données spécifiques de \dx{} (les enseignants, les locaux, les cours, les étudiants, la grille horaire, etc), répond aux demandes d'informations sur son état (souvent issues de la vue) ainsi qu'aux instructions de changement d'état (souvent issues du contrôleur).
    \item[La vue:] elle offre un ensemble fenêtre, dialogue, menu, etc permettant une mise en page de l'affichage d'informations. Il permet à l'utilisateur de faire des requêtes sur le modèle et de visualiser les résultats.
    \item[Le contrôleur:] il gère les événements d'entrée de l'utilisateur à partir de la souris ou du clavier. Chaque vue à un contrôleur associé qui la connecte avec avec les périphérique d'entrée.
\end{description}    

\subsection{Description du modèle}

Le modèle de \dx{} est bâti autour de quatre principaux sous-composants: le sous-composant \verb!model!, le sous-composant \verb!data!, le sous-composant \verb!ttstructure! et le sous-composant \verb!optimization! (voir figure \ref{model}).

\begin{figure*}[h]
  % Requires \usepackage{graphicx}
  \begin{center}
    \includegraphics[width=350pt]{SDD/images/Component-Global.eps}
    \caption{Architecture du composant modèle de \dx{}}\label{model}
  \end{center}
\end{figure*} 

\subsubsection{Description du sous-composant model}

Le sous-composant \verb!model! représente le point d'entrée du composant modèle (de l'architecture MVC), il est l'interface à travers laquelle le modèle communique avec les autres composants que sont la vue et le contrôleur. Il implémente donc uniquement les méthodes utiles à la vue et au contrôleur. 

La conception du sous-composant model est faite de sorte à l'organiser autour de trois entités: l'entité model, l'entité structure et l'entité comportement ou processus (voir figure \ref{submodel}). 

\begin{figure*}[h]
  % Requires \usepackage{graphicx}
  \begin{center}
    \includegraphics[width=350pt]{SDD/images/sub_component_model.eps}
    \caption{Description du sous-composant model}\label{submodel}
  \end{center}
\end{figure*} 

\begin{description}
    \item[L'entité structure: ] elle fournit les interfaces permettant d'accéder aux données (étudiants, instructeurs, locaux, activités et grille horaire).
    \item[L'entité process: ] elle fournit les interfaces permettant de lancer les opérations sur les données (création des événements, algorithmes, etc).
    \item[L'entité model: ] elle regroupe les interfaces offertes par l'entité structure et l'entité process.
\end{description}    

Vue le nombre d'interfaces qu'il pourrait avoir entre l'entité structure et l'entité model, vue la redondance de ces interfaces dans l'entité model, il est paru nécessaire de réorganiser ces entités et de les faire passer de trois à deux. Ainsi le sous-composant model sera réorganisé autour de deux entités: l'entité model-structure et l'entité process.

\begin{description}
    \item[L'entité process: ] elle fournit les interfaces permettant de lancer les opérations sur les données (création des événements, algorithmes, etc).
    \item[L'entité model-structure: ] elle regroupe les interfaces offertes par l'entité process en plus de celles permettant d'accéder aux données.
\end{description} 

\subsubsection{Description du sous-composant data}

Le sous-composant data (voir figure \ref{subdata}) permet tout d'abord de gérer les accès aux données physiques (lecture et écriture). Il permet ensuite d'organiser les données sous une forme prédéfinie (structure de données). Il permet enfin de manipuler ces données (ajout, suppression, modification, recherche, tri).

\begin{figure*}[h]
  % Requires \usepackage{graphicx}
  \begin{center}
    \includegraphics[width=350pt]{SDD/images/sub_component_data.eps}
    \caption{Description du sous-composant data}\label{subdata}
  \end{center}
\end{figure*} 

\subsection{Description de la vue}

\subsection{Description du contrôleur}

\subsection{Problèmes de conception}

L'architecture de \dx{} n'est pas totalement conforme au modèle MVC. En effet, certaines vues (exp: \verb!dInterface.dAffectation.EditActivityDlg.ApplyChanges()!) implémentent des méthodes modifiant l'état du modèle, ce qui créait une dépendance bi-directionnelle entre le modèle et la vue.

\section{Décomposition des processus concurrents} \label{process}
\subsection{Description du processus 1}
\subsection{Description du processus 2}

\section{Décomposition des données} \label{data}
\subsection{Description des entrée de données 1}
\subsection{Description des entrée de données 2}

\section{Modélisation des états}

\section{Modélisation des cas d'utilisation}
